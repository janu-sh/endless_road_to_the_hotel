<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Road to the Hotel</title>
    
    <!-- 
      SECTION 3.1: VISUAL & THEMATIC DESIGN (FONT)
      Import the 'Luckiest Guy' font from Google Fonts.
    -->
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet">
    
    <style>
        /* CSS from Section 2 (Technology) and 3 (Theme)
        */
        @font-face {
            font-family: 'Luckiest Guy';
            src: url('https://fonts.gstatic.com/s/luckiestguy/v18/K2FufimYLv0A-h2eYEE-6A.woff2') format('woff2');
            font-display: swap;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #333; /* Dark background to contrast the game */
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            font-family: 'Luckiest Guy', sans-serif;
            overflow: hidden;
        }

        #game-container {
            width: 1000px;
            max-width: 100%;
            height: 600px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            
            /* This class is added by the WebFontLoader (in BootScene) 
              to prevent the game from showing with the wrong font (FOUT).
            */
            visibility: hidden;
        }

        #game-container.font-loaded {
            visibility: visible;
        }

        canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
    </style>

    <!-- Load the Phaser 3 Library -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    
    <!-- Load the WebFontLoader to safely load our custom font -->
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <script>
        // --- 1. CONFIGURATION (From Design Doc Sections 4.1, 4.4, 4.7) ---

        const GAME_WIDTH = 1000;
        const GAME_HEIGHT = 600;
        
        // Player Physics
        const PLAYER_JUMP_VELOCITY = -750;
        const GRAVITY = 1800;
        
        // Ground position (invisible)
        const GROUND_Y = GAME_HEIGHT - 30;

        // Game Speed & Scoring
        const INITIAL_GAME_SPEED = 8;
        const GAME_SPEED_INCREMENT = 0.005; // How much speed increases per score point
        
        // Camera Zoom & Player Movement
        const INITIAL_ZOOM = 1.0;
        const MAX_ZOOM = 2.0; // Maximum zoom level
        const ZOOM_INCREMENT = 0.001; // How much zoom increases per score point
        const PLAYER_INITIAL_X = 150;
        const PLAYER_TARGET_X = 600; // How far right the player moves (in world space)
        const PLAYER_MOVEMENT_SPEED = 0.002; // How quickly player moves right (slower = more dramatic)
        
        // Boss Movement
        const BOSS_INITIAL_X = GAME_WIDTH - 130; // Starting position on right side
        const BOSS_TARGET_X = 700; // How far left the boss moves (in world space)
        const BOSS_MOVEMENT_SPEED = 0.001; // How quickly boss moves left (different from player for asymmetric effect)
        
        // Credits Screen
        const CREDIT_THRESHOLD = 1000; // Points needed to unlock credits
        
        // Rain Effect Toggle
        const RAIN_ENABLED = true; // Set to false to disable rain particles
        
        // FPS Counter Toggle
        const FPS_ENABLED = true; // Set to false to hide FPS counter
        
        // Boss Attack Timing
        const BOSS_ANIMATION_DURATION = 300; // How long boss animation plays (ms)
        const BOSS_ATTACK_DELAY = 200; // Delay between animation start and obstacle spawn (ms)

        // --- 2. ASSET DEFINITIONS (Loaded from assets.json) ---
        // This will be populated by BootScene after loading assets.json
        let ASSETS = null;

        // --- 3. OBSTACLE CONFIGURATIONS (Loaded from assets.json) ---
        // These will be populated by BootScene after loading assets.json
        let GROUND_OBSTACLE_CONFIGS = [];
        let FLYING_OBSTACLE_CONFIGS = [];

        // --- 4. GAME SCENES (Implements Section 4.5: Game States) ---

        /**
         * BootScene (State: LOADING)
         * Loads all game assets and the custom font.
         * Transitions to the GameScene and UIScene once loading is complete.
         */
        class BootScene extends Phaser.Scene {
            constructor() {
                super({ key: 'BootScene' });
            }

            preload() {
                console.log('BootScene: preload');
                
                // Show a simple loading text
                const loadingStyle = { font: "32px Arial", fill: "#FFFFFF" };
                this.loadingText = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, "LOADING...", loadingStyle).setOrigin(0.5);

                // Load assets.json first
                this.load.json('assetsData', 'assets.json');
                
                // Load the 'Luckiest Guy' font using the WebFontLoader
                // this.loadWebFont(); // <-- MOVED: This was called too early, creating a race condition.
            }

            create() {
                console.log('BootScene: create (assets.json loaded)');
                
                // Get the loaded assets data
                const assetsData = this.cache.json.get('assetsData');
                
                // Convert to uppercase keys for backward compatibility
                ASSETS = {
                    PLAYER: assetsData.player,
                    PLAYER_DUCK: assetsData.player_duck,
                    SIDEKICK: assetsData.sidekick,
                    SIDEKICK_DUCK: assetsData.sidekick_duck,
                    BACKGROUND_FAR: assetsData.background_far,
                    BACKGROUND_MID: assetsData.background_mid,
                    BACKGROUND_NEAR: assetsData.background_near,
                    OBSTACLE_SMALL: assetsData.obstacle_small,
                    OBSTACLE_LARGE: assetsData.obstacle_large,
                    OBSTACLE_FLYING: assetsData.obstacle_flying,
                    BOSS: assetsData.boss,
                    BOSS_THROW: assetsData.boss_throw,
                    BOSS_KICK: assetsData.boss_kick
                };
                
                // Populate obstacle configurations from assets data
                GROUND_OBSTACLE_CONFIGS = [
                    {
                        key: ASSETS.OBSTACLE_SMALL.key,
                        hitbox: ASSETS.OBSTACLE_SMALL.hitbox
                    },
                    {
                        key: ASSETS.OBSTACLE_LARGE.key,
                        hitbox: ASSETS.OBSTACLE_LARGE.hitbox
                    }
                ];
                
                FLYING_OBSTACLE_CONFIGS = [
                    {
                        key: ASSETS.OBSTACLE_FLYING.key,
                        hitbox: ASSETS.OBSTACLE_FLYING.hitbox
                    }
                ];
                
                // Now load all the images
                this.load.image(ASSETS.PLAYER.key, ASSETS.PLAYER.url);
                this.load.image(ASSETS.PLAYER_DUCK.key, ASSETS.PLAYER_DUCK.url);
                this.load.image(ASSETS.SIDEKICK.key, ASSETS.SIDEKICK.url);
                this.load.image(ASSETS.SIDEKICK_DUCK.key, ASSETS.SIDEKICK_DUCK.url);
                this.load.image(ASSETS.BACKGROUND_FAR.key, ASSETS.BACKGROUND_FAR.url);
                this.load.image(ASSETS.BACKGROUND_MID.key, ASSETS.BACKGROUND_MID.url);
                this.load.image(ASSETS.BACKGROUND_NEAR.key, ASSETS.BACKGROUND_NEAR.url);
                this.load.image(ASSETS.OBSTACLE_SMALL.key, ASSETS.OBSTACLE_SMALL.url);
                this.load.image(ASSETS.OBSTACLE_LARGE.key, ASSETS.OBSTACLE_LARGE.url);
                this.load.image(ASSETS.OBSTACLE_FLYING.key, ASSETS.OBSTACLE_FLYING.url);
                this.load.image(ASSETS.BOSS.key, ASSETS.BOSS.url);
                this.load.image(ASSETS.BOSS_THROW.key, ASSETS.BOSS_THROW.url);
                this.load.image(ASSETS.BOSS_KICK.key, ASSETS.BOSS_KICK.url);
                
                // Start loading the images
                this.load.once('complete', () => {
                    console.log('BootScene: All images loaded');
                    // Now load the font
                    this.loadWebFont();
                });
                
                this.load.start();
            }

            loadWebFont() {
                WebFont.load({
                    google: {
                        families: ['Luckiest Guy']
                    },
                    active: () => {
                        console.log('Font loaded.');
                        // Add class to game container to make it visible
                        document.getElementById('game-container').classList.add('font-loaded');
                        // Font is loaded, proceed to start the game
                        this.startGame();
                    },
                    inactive: () => {
                        console.warn('Font could not be loaded, using fallback.');
                        // Still start the game, browser will use a fallback
                        document.getElementById('game-container').classList.add('font-loaded');
                        this.startGame();
                    }
                });
            }

            startGame() {
                if (this.loadingText) this.loadingText.destroy();
                
                // Start the main game scene
                this.scene.start('GameScene');
                
                // Start the UI scene in parallel, on top of the GameScene
                this.scene.start('UIScene');
            }
        }
        
        /**
         * GameScene (State: PLAYING)
         * Handles all core game logic: player, obstacles, physics, and scoring.
         */
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
            }

            init() {
                // Reset all game variables
                this.score = 0;
                this.gameSpeed = INITIAL_GAME_SPEED;
                this.isGameOver = false;
                this.playerIsDucking = false;
                this.currentZoom = INITIAL_ZOOM;
                
                // Action queue for sidekicks to mirror hero's actions
                this.actionQueue = [];
                
                // Rain particle arrays
                this.rainParticles = [];
                this.splashParticles = [];
            }

            create() {
                console.log('GameScene: create');
                // --- Parallax Scrolling Backgrounds (Section 4.3) ---
                // Multiple layers create depth through different scroll speeds
                this.backgroundFar = this.add.tileSprite(0, 0, GAME_WIDTH, GAME_HEIGHT, ASSETS.BACKGROUND_FAR.key)
                    .setOrigin(0, 0)
                    .setScrollFactor(0)
                    .setAlpha(0.8) // Slightly transparent for depth
                    .setDepth(-10); // Farthest back
                
                this.backgroundMid = this.add.tileSprite(0, 0, GAME_WIDTH, GAME_HEIGHT, ASSETS.BACKGROUND_MID.key)
                    .setOrigin(0, 0)
                    .setScrollFactor(0)
                    .setAlpha(0.9)
                    .setDepth(-9); // Middle background
                
                this.backgroundNear = this.add.tileSprite(0, 0, GAME_WIDTH, GAME_HEIGHT, ASSETS.BACKGROUND_NEAR.key)
                    .setOrigin(0, 0)
                    .setScrollFactor(0)
                    .setDepth(-8); // Nearest background

                // --- Invisible Ground ---
                // We create a static, invisible physics body for the ground
                this.ground = this.physics.add.staticSprite(GAME_WIDTH / 2, GROUND_Y + 10, null)
                    .setSize(GAME_WIDTH, 20)
                    .setVisible(false);

                // --- Player (Section 4.1) ---
                // Create player shadow (ellipse on the ground)
                this.playerShadow = this.add.graphics();
                this.playerShadow.setDepth(1); // Render above background, below player
                
                this.player = this.physics.add.sprite(PLAYER_INITIAL_X, GROUND_Y, ASSETS.PLAYER.key)
                    .setOrigin(0.5, 1) // <-- THE FIX: Anchor sprite to bottom-center
                    .setCollideWorldBounds(true)
                    .setDepth(2); // Render above shadow
                
                // Set the player's hitbox from assets.json
                const playerHitbox = ASSETS.PLAYER.hitbox;
                this.player.body.setSize(playerHitbox.width, playerHitbox.height)
                    .setOffset(playerHitbox.offsetX, playerHitbox.offsetY);

                // Add collider between player and ground
                this.physics.add.collider(this.player, this.ground);

                // --- Sidekicks (positioned to the left of hero) ---
                this.sidekicks = [];
                const sidekickOffsets = [-60, -90]; // X offsets from player
                const sidekickDelays = [150, 300]; // Delays in milliseconds
                
                for (let i = 0; i < 2; i++) {
                    // Create sidekick shadow
                    const sidekickShadow = this.add.graphics();
                    sidekickShadow.setDepth(1); // Render above background, below sidekick
                    
                    // Use regular sprites (not physics sprites) since they just mirror visually
                    const sidekick = this.add.sprite(
                        PLAYER_INITIAL_X + sidekickOffsets[i], 
                        GROUND_Y, 
                        ASSETS.SIDEKICK.key
                    )
                        .setOrigin(0.5, 1)
                        .setScale(0.90) // Slightly smaller than hero
                        .setAlpha(0.90) // Slightly transparent to distinguish from hero
                        .setDepth(2); // Render above shadow
                    
                    this.sidekicks.push({
                        sprite: sidekick,
                        shadow: sidekickShadow,
                        delay: sidekickDelays[i],
                        isDucking: false,
                        isJumping: false,
                        jumpStartY: GROUND_Y,
                        jumpVelocity: 0,
                        xOffset: sidekickOffsets[i]
                    });
                }

                // --- Boss Character (starts on right side, moves left) ---
                const bossX = BOSS_INITIAL_X; // Starting position on right side
                const bossY = GROUND_Y; // Standing on ground
                
                // Create boss shadow
                this.bossShadow = this.add.graphics();
                this.bossShadow.setDepth(9); // Render below boss but above obstacles
                
                this.boss = this.add.sprite(bossX, bossY, ASSETS.BOSS.key)
                    .setOrigin(0.5, 1) // Anchor to bottom-center
                    .setDepth(10); // Render above obstacles

                // --- Camera Setup ---
                // Set camera origin to bottom so zoom grows upward
                this.cameras.main.setZoom(INITIAL_ZOOM);
                // Set origin to bottom-center (0.5, 1) so zoom expands upward from ground
                this.cameras.main.setOrigin(0.5, 1);
                this.initialCameraX = GAME_WIDTH / 2;

                // --- Rain Particle System ---
                this.rainGraphics = this.add.graphics();
                this.splashGraphics = this.add.graphics();
                
                // Set depth so rain appears in front of background but behind characters
                this.rainGraphics.setDepth(5);
                this.splashGraphics.setDepth(6);
                
                // Timer to spawn rain particles (will be started when game begins)
                this.rainTimer = this.time.addEvent({
                    delay: 50, // Spawn rain less frequently for performance
                    callback: this.spawnRain,
                    callbackScope: this,
                    loop: true,
                    paused: true // Start paused, will resume on first click
                });
                
                // Limit max particles for performance
                this.maxRainParticles = 50;
                this.maxSplashParticles = 50;

                // --- Obstacles (Section 4.2 & 4.6) ---
                this.obstacleGroup = this.physics.add.group({
                    allowGravity: false,
                    immovable: true
                });

                // Add collision handler
                this.physics.add.overlap(this.player, this.obstacleGroup, this.hitObstacle, null, this);

                // Timer to spawn obstacles (will be started when game begins)
                this.spawnTimer = this.time.addEvent({
                    delay: 2000, // Initial delay
                    callback: this.spawnObstacle,
                    callbackScope: this,
                    loop: true,
                    paused: true // Start paused, will resume on first click
                });

                // --- Input (Section 4.1) ---
                this.input.on('pointerdown', this.jump, this);
                this.input.keyboard.on('keydown-SPACE', this.jump, this);
                this.input.keyboard.on('keydown-DOWN', this.duck, this);
                this.input.keyboard.on('keyup-DOWN', this.standUp, this);

                // --- Start Screen (Section 4.5: READY) ---
                const startTextStyle = { 
                    fontFamily: '"Luckiest Guy", sans-serif', 
                    fontSize: '64px', 
                    color: '#FFF', 
                    stroke: '#000', 
                    strokeThickness: 8 
                };
                this.startText = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'CLICK TO START', startTextStyle).setOrigin(0.5);
                
                // Pause the game until the first click
                this.physics.pause();
            }

            jump() {
                if (this.isGameOver || this.playerIsDucking) return;

                // Handle the first click (READY -> PLAYING state)
                if (this.physics.world.isPaused) {
                    this.physics.resume();
                    this.startText.destroy();
                    // Resume timers when game starts
                    this.spawnTimer.paused = false;
                    this.rainTimer.paused = false;
                }

                // Only jump if touching the ground
                if (this.player.body.touching.down) {
                    this.player.setVelocityY(PLAYER_JUMP_VELOCITY);
                    
                    // Record action for sidekicks
                    this.actionQueue.push({
                        type: 'jump',
                        time: this.time.now
                    });
                }
            }

            duck() {
                if (this.isGameOver || !this.player.body.touching.down || this.playerIsDucking) return;

                this.playerIsDucking = true;
                this.player.setTexture(ASSETS.PLAYER_DUCK.key);

                // Set hitbox from assets.json
                const duckHitbox = ASSETS.PLAYER_DUCK.hitbox;
                this.player.body.setSize(duckHitbox.width, duckHitbox.height)
                    .setOffset(duckHitbox.offsetX, duckHitbox.offsetY);
                
                // Record action for sidekicks
                this.actionQueue.push({
                    type: 'duck',
                    time: this.time.now
                });
            }

            standUp() {
                if (this.isGameOver || !this.playerIsDucking) return;

                this.playerIsDucking = false;
                this.player.setTexture(ASSETS.PLAYER.key);
                
                // Restore original hitbox from assets.json
                const playerHitbox = ASSETS.PLAYER.hitbox;
                this.player.body.setSize(playerHitbox.width, playerHitbox.height)
                    .setOffset(playerHitbox.offsetX, playerHitbox.offsetY);
                
                // Record action for sidekicks
                this.actionQueue.push({
                    type: 'standup',
                    time: this.time.now
                });
            }

            spawnObstacle() {
                // Randomly pick a spawn type
                const spawnType = Phaser.Math.RND.pick(['ground', 'ground', 'flying']); // 2:1 chance of ground

                if (spawnType === 'ground') {
                    // --- Boss Kicks Ground Obstacle ---
                    const config = Phaser.Math.RND.pick(GROUND_OBSTACLE_CONFIGS);

                    // Boss kick animation (telegraph)
                    this.boss.setTexture(ASSETS.BOSS_KICK.key);
                    
                    // Return boss to normal after animation
                    this.time.delayedCall(BOSS_ANIMATION_DURATION, () => {
                        if (this.boss) this.boss.setTexture(ASSETS.BOSS.key);
                    });

                    // Delay obstacle spawn to give player reaction time
                    this.time.delayedCall(BOSS_ATTACK_DELAY, () => {
                        // Spawn obstacle near boss position
                        const spawnX = this.boss.x - 80; // Spawn near boss's feet
                        const obstacle = this.obstacleGroup.create(spawnX, GROUND_Y, config.key)
                            .setOrigin(0.5, 1) // Anchor to bottom-center
                            .refreshBody(); // Apply changes

                        // Set the custom hitbox based on our config
                        obstacle.body.setSize(config.hitbox.width, config.hitbox.height);
                    });
                } else {
                    // --- Boss Throws Flying Obstacle ---
                    const config = Phaser.Math.RND.pick(FLYING_OBSTACLE_CONFIGS);

                    // Boss throw animation (telegraph)
                    this.boss.setTexture(ASSETS.BOSS_THROW.key);
                    
                    // Return boss to normal after animation
                    this.time.delayedCall(BOSS_ANIMATION_DURATION, () => {
                        if (this.boss) this.boss.setTexture(ASSETS.BOSS.key);
                    });

                    // Delay obstacle spawn to give player reaction time
                    this.time.delayedCall(BOSS_ATTACK_DELAY, () => {
                        // Spawn at a height the player must duck under, near boss's hand
                        const spawnX = this.boss.x - 80; // Spawn near boss
                        const spawnY = GROUND_Y - 45; // 45px above ground

                        const obstacle = this.obstacleGroup.create(spawnX, spawnY, config.key)
                            .setOrigin(0.5, 1) // Anchor to bottom-center
                            .refreshBody();

                        // Set custom hitbox
                        obstacle.body.setSize(config.hitbox.width, config.hitbox.height);
                    });
                }

                
                // Update the spawn timer for the *next* obstacle
                // This creates the semi-random gap from Section 4.2
                this.spawnTimer.delay = Phaser.Math.Between(1500, 3500) / (this.gameSpeed / INITIAL_GAME_SPEED);
            }

            hitObstacle(player, obstacle) {
                if (this.isGameOver) return; // Prevent multiple triggers

                console.log('Game Over');
                this.isGameOver = true;
                this.physics.pause();
                this.spawnTimer.remove();
                this.rainTimer.remove();

                // Ensure player is standing on game over
                this.standUp();

                // Visual feedback
                this.player.setTint(0xff0000); // Red tint
                this.cameras.main.shake(300, 0.01);

                // --- Game Over (Section 4.5) ---
                // After a delay, launch the GameOver scene
                // Pass the final score to it
                this.time.delayedCall(500, () => {
                    this.scene.launch('GameOverScene', { 
                        score: Math.floor(this.score) 
                    });
                });
            }

            spawnRain() {
                // Don't spawn if rain is disabled
                if (!RAIN_ENABLED) {
                    return;
                }
                
                // Only spawn if under particle limit
                if (this.rainParticles.length >= this.maxRainParticles) {
                    return;
                }
                
                // Spawn 1 rain particle at a time
                // Spawn further to the right to compensate for leftward wind push
                const x = Phaser.Math.Between(-50, GAME_WIDTH + 400);
                const y = -10;
                const speed = Phaser.Math.Between(500, 700);
                
                // Calculate horizontal wind speed based on game speed
                // As game gets faster, rain appears more horizontal
                const windSpeed = 500 + (this.gameSpeed - INITIAL_GAME_SPEED) * 200; // Scales with speed increase
                
                // Progressive rain streak length - gets longer as game progresses
                // Base length: 15-25px, increases with game speed
                const speedMultiplier = (this.gameSpeed - INITIAL_GAME_SPEED) / INITIAL_GAME_SPEED; // 0 to ~2+ over time
                const baseLengthMin = 10 + (speedMultiplier * 30); // 15 -> 35+
                const baseLengthMax = 25 + (speedMultiplier * 50); // 25 -> 55+
                const length = Phaser.Math.Between(baseLengthMin, baseLengthMax);
                
                this.rainParticles.push({
                    x: x,
                    y: y,
                    speed: speed,
                    windSpeed: windSpeed,
                    length: length,
                    alpha: Phaser.Math.FloatBetween(0.5, 0.8) // More visible
                });
            }

            createSplash(x, y) {
                // Only create splash if under particle limit
                if (this.splashParticles.length >= this.maxSplashParticles) {
                    return;
                }
                
                // Create 2-3 small, subtle splash particles
                const count = Phaser.Math.Between(2, 3);
                for (let i = 0; i < count; i++) {
                    const angle = Phaser.Math.Between(-30, 30) - 90; // Spray upward (narrower angle)
                    const speed = Phaser.Math.Between(30, 80); // Slower, less dramatic
                    const rad = Phaser.Math.DegToRad(angle);
                    
                    this.splashParticles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(rad) * speed,
                        vy: Math.sin(rad) * speed,
                        life: 200, // Shorter lifetime (milliseconds)
                        maxLife: 200,
                        size: Phaser.Math.FloatBetween(1, 2) // Smaller particles
                    });
                }
            }

            checkRainCollisions(rain) {
                // Check collision with ground
                if (rain.y >= GROUND_Y - 5) {
                    this.createSplash(rain.x, GROUND_Y);
                    return true;
                }

                // Check collision with player
                const playerBounds = this.player.getBounds();
                if (Phaser.Geom.Rectangle.Contains(playerBounds, rain.x, rain.y)) {
                    this.createSplash(rain.x, rain.y);
                    return true;
                }

                // Check collision with sidekicks
                for (let sidekick of this.sidekicks) {
                    const bounds = sidekick.sprite.getBounds();
                    if (Phaser.Geom.Rectangle.Contains(bounds, rain.x, rain.y)) {
                        this.createSplash(rain.x, rain.y);
                        return true;
                    }
                }

                // Check collision with boss
                const bossBounds = this.boss.getBounds();
                if (Phaser.Geom.Rectangle.Contains(bossBounds, rain.x, rain.y)) {
                    this.createSplash(rain.x, rain.y);
                    return true;
                }

                // Check collision with obstacles
                for (let obstacle of this.obstacleGroup.getChildren()) {
                    const obstacleBounds = obstacle.getBounds();
                    if (Phaser.Geom.Rectangle.Contains(obstacleBounds, rain.x, rain.y)) {
                        this.createSplash(rain.x, rain.y);
                        return true;
                    }
                }

                return false;
            }

            updateShadow(shadowGraphics, characterX, characterY, baseWidth, baseHeight) {
                // Calculate how high the character is above the ground
                const heightAboveGround = GROUND_Y - characterY;
                
                // Shadow shrinks as character jumps higher
                // At ground level: full size, at max jump height (~200px): 30% size
                const shrinkFactor = Math.max(0.3, 1 - (heightAboveGround / 400));
                
                const shadowWidth = baseWidth * shrinkFactor;
                const shadowHeight = baseHeight * shrinkFactor;
                
                // Shadow also becomes more transparent when character is higher
                const shadowAlpha = 0.3 * shrinkFactor;
                
                // Clear and redraw shadow
                shadowGraphics.clear();
                shadowGraphics.fillStyle(0x000000, shadowAlpha);
                shadowGraphics.fillEllipse(characterX, GROUND_Y, shadowWidth, shadowHeight);
            }

            update(time, delta) {
                if (this.isGameOver || this.physics.world.isPaused) {
                    return;
                }

                // --- Parallax Scrolling Backgrounds (Section 4.3) ---
                // Each layer scrolls at different speed for depth effect
                this.backgroundFar.tilePositionX += (this.gameSpeed * 0.2);   // Slowest - farthest away
                this.backgroundMid.tilePositionX += (this.gameSpeed * 0.5);   // Medium speed
                this.backgroundNear.tilePositionX += (this.gameSpeed * 0.8);  // Fastest - closest to camera

                // --- Update Obstacles ---
                // Move all obstacles in the group to the left
                Phaser.Actions.IncX(this.obstacleGroup.getChildren(), -this.gameSpeed);

                // --- Scoring & Speed (Section 4.4) ---
                // Increase score over time
                this.score += delta * 0.01;
                
                // Increase game speed based on score
                this.gameSpeed = INITIAL_GAME_SPEED + (this.score * GAME_SPEED_INCREMENT);

                // --- Progressive Zoom & Player Movement ---
                // Gradually zoom in as score increases
                this.currentZoom = Math.min(MAX_ZOOM, INITIAL_ZOOM + (this.score * ZOOM_INCREMENT));
                this.cameras.main.setZoom(this.currentZoom);

                // Move player slowly towards boss (in world space) for dramatic "catching up" effect
                const playerProgressRatio = Math.min(1, this.score * PLAYER_MOVEMENT_SPEED); // 0 to 1 over time
                const playerTargetX = PLAYER_INITIAL_X + (PLAYER_TARGET_X - PLAYER_INITIAL_X) * playerProgressRatio;
                this.player.x = playerTargetX;
                
                // --- Update Player Shadow ---
                this.updateShadow(this.playerShadow, this.player.x, this.player.y, 50, 12);
                
                // --- Update Sidekicks ---
                // Process action queue for each sidekick
                this.sidekicks.forEach((sidekick, sidekickIndex) => {
                    // Keep sidekick positioned relative to player
                    sidekick.sprite.x = this.player.x + sidekick.xOffset;
                    
                    // Manual jump physics for visual-only sprites
                    if (sidekick.isJumping) {
                        sidekick.jumpVelocity += GRAVITY * (delta / 1000);
                        sidekick.sprite.y += sidekick.jumpVelocity * (delta / 1000);
                        
                        // Land on ground
                        if (sidekick.sprite.y >= GROUND_Y) {
                            sidekick.sprite.y = GROUND_Y;
                            sidekick.isJumping = false;
                            sidekick.jumpVelocity = 0;
                        }
                    }
                    
                    // Process actions with delay
                    this.actionQueue.forEach(action => {
                        const timeSinceAction = this.time.now - action.time;
                        
                        // Initialize processed array if it doesn't exist
                        if (!action.processedBy) {
                            action.processedBy = [];
                        }
                        
                        // Check if it's time for this sidekick to perform the action
                        // and if it hasn't been processed yet by this sidekick
                        if (timeSinceAction >= sidekick.delay && !action.processedBy.includes(sidekickIndex)) {
                            action.processedBy.push(sidekickIndex);
                            
                            if (action.type === 'jump' && !sidekick.isJumping) {
                                sidekick.isJumping = true;
                                sidekick.jumpVelocity = PLAYER_JUMP_VELOCITY;
                            } else if (action.type === 'duck' && !sidekick.isDucking) {
                                sidekick.isDucking = true;
                                sidekick.sprite.setTexture(ASSETS.SIDEKICK_DUCK.key);
                            } else if (action.type === 'standup' && sidekick.isDucking) {
                                sidekick.isDucking = false;
                                sidekick.sprite.setTexture(ASSETS.SIDEKICK.key);
                            }
                        }
                    });
                    
                    // Update sidekick shadow
                    this.updateShadow(sidekick.shadow, sidekick.sprite.x, sidekick.sprite.y, 45, 10);
                });
                
                // Clean up old actions (older than 1 second)
                this.actionQueue = this.actionQueue.filter(action => {
                    return this.time.now - action.time < 1000;
                });
                
                // Move boss slowly towards player (in world space) for dramatic "closing the gap" effect
                const bossProgressRatio = Math.min(1, this.score * BOSS_MOVEMENT_SPEED); // 0 to 1 over time
                const bossTargetX = BOSS_INITIAL_X - (BOSS_INITIAL_X - BOSS_TARGET_X) * bossProgressRatio;
                this.boss.x = bossTargetX;
                
                // --- Update Boss Shadow ---
                this.updateShadow(this.bossShadow, this.boss.x, GROUND_Y, 60, 15);

                // Adjust camera to keep player and boss on opposite sides of screen
                // As we zoom in, we need to pan the camera to maintain framing
                const zoomProgress = (this.currentZoom - INITIAL_ZOOM) / (MAX_ZOOM - INITIAL_ZOOM);
                const cameraOffsetX = zoomProgress * 125; // Pan camera right as we zoom
                this.cameras.main.scrollX = cameraOffsetX;
                
                // Keep ground level at bottom of screen as we zoom
                // Adjust Y scroll to compensate for zoom origin at bottom
                this.cameras.main.scrollY = 0;

                // Emit event for UIScene to update (includes zoom level for UI positioning)
                this.events.emit('updateScore', Math.floor(this.score), this.currentZoom);

                // --- Cleanup ---
                // Destroy obstacles that are off-screen
                this.obstacleGroup.getChildren().forEach(obstacle => {
                    if (obstacle.getBounds().right < 0) {
                        obstacle.destroy();
                    }
                });

                // --- Update Rain Particles ---
                if (RAIN_ENABLED) {
                    this.rainGraphics.clear();
                    this.rainGraphics.lineStyle(2.5, 0x88ccff, 1); // Thicker, more visible lines
                    
                    // Update and draw rain
                    this.rainParticles = this.rainParticles.filter(rain => {
                    // Move rain down and to the left (simulating wind from running right)
                    rain.y += rain.speed * (delta / 1000);
                    rain.x -= rain.windSpeed * (delta / 1000);
                    
                    // Check for collisions
                    if (this.checkRainCollisions(rain)) {
                        return false; // Remove this rain particle
                    }
                    
                    // Remove if off screen
                    if (rain.y > GAME_HEIGHT + 20) {
                        return false;
                    }
                    
                    // Draw rain drop as an angled line based on wind speed
                    this.rainGraphics.setAlpha(rain.alpha);
                    this.rainGraphics.beginPath();
                    this.rainGraphics.moveTo(rain.x, rain.y);
                    // End point is offset horizontally by wind effect
                    const angleOffset = (rain.windSpeed / rain.speed) * rain.length;
                    this.rainGraphics.lineTo(rain.x + angleOffset, rain.y - rain.length);
                    this.rainGraphics.strokePath();
                    
                        return true; // Keep this rain particle
                    });

                    // --- Update Splash Particles ---
                    this.splashGraphics.clear();
                    this.splashGraphics.fillStyle(0xaaddff, 0.6); // More transparent
                    
                    this.splashParticles = this.splashParticles.filter(splash => {
                    // Update position
                    splash.x += splash.vx * (delta / 1000);
                    splash.y += splash.vy * (delta / 1000);
                    
                    // Apply gravity to splash
                    splash.vy += 500 * (delta / 1000);
                    
                    // Decrease life
                    splash.life -= delta;
                    
                    // Remove if life is over
                    if (splash.life <= 0) {
                        return false;
                    }
                    
                    // Draw splash particle as a circle
                    const alpha = splash.life / splash.maxLife;
                    this.splashGraphics.setAlpha(alpha);
                    this.splashGraphics.fillCircle(splash.x, splash.y, splash.size);
                    
                        return true; // Keep this splash particle
                    });
                }
            }
        }

        /**
         * UIScene (State: PLAYING_UI)
         * Runs in parallel to GameScene.
         * Only responsible for displaying the score.
         */
        class UIScene extends Phaser.Scene {
            constructor() {
                super({ key: 'UIScene' });
            }

            create() {
                console.log('UIScene: create');
                
                // --- UI Style (Section 3: Theme) ---
                const scoreStyle = {
                    fontFamily: '"Luckiest Guy", sans-serif',
                    fontSize: '48px',
                    color: '#FFFFFF',
                    align: 'right',
                    stroke: '#000000',
                    strokeThickness: 6
                };

                this.scoreText = this.add.text(GAME_WIDTH - 30, 30, 'SCORE: 0', scoreStyle)
                    .setOrigin(1, 0);

                // --- FPS Counter Style ---
                if (FPS_ENABLED) {
                    const fpsStyle = {
                        fontFamily: '"Luckiest Guy", sans-serif',
                        fontSize: '24px',
                        color: '#00ff00',
                        align: 'left',
                        stroke: '#000000',
                        strokeThickness: 4
                    };

                    this.fpsText = this.add.text(20, 20, 'FPS: 60', fpsStyle)
                        .setOrigin(0, 0);
                }

                // Listen for the 'updateScore' event from GameScene
                const gameScene = this.scene.get('GameScene');
                gameScene.events.on('updateScore', (score, zoom) => {
                    this.scoreText.setText('SCORE: ' + score);
                    // Keep UI text properly positioned as camera zooms
                    // The UI scene doesn't zoom, so we don't need to adjust
                });
            }

            update() {
                // Update FPS counter
                if (FPS_ENABLED && this.fpsText) {
                    const fps = Math.round(this.game.loop.actualFps);
                    this.fpsText.setText('FPS: ' + fps);
                    
                    // Color code based on performance
                    if (fps >= 50) {
                        this.fpsText.setColor('#00ff00'); // Green for good FPS
                    } else if (fps >= 30) {
                        this.fpsText.setColor('#ffff00'); // Yellow for moderate FPS
                    } else {
                        this.fpsText.setColor('#ff0000'); // Red for poor FPS
                    }
                }
            }
        }

        /**
         * GameOverScene (States: GAME_OVER, CREDITS)
         * Displays the final score and handles restart/credits logic.
         */
        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
            }

            init(data) {
                this.finalScore = data.score;
            }

            create() {
                console.log('GameOverScene: create');
                // Dark overlay
                this.add.rectangle(0, 0, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.7).setOrigin(0);

                // --- UI Styles (Section 3: Theme) ---
                const titleStyle = { 
                    fontFamily: '"Luckiest Guy", sans-serif', 
                    fontSize: '96px', 
                    color: '#ef4444', 
                    stroke: '#000', 
                    strokeThickness: 10 
                };
                const scoreStyle = { 
                    fontFamily: '"Luckiest Guy", sans-serif', 
                    fontSize: '64px', 
                    color: '#FFF', 
                    stroke: '#000', 
                    strokeThickness: 8 
                };
                const buttonStyle = { 
                    fontFamily: '"Luckiest Guy", sans-serif', 
                    fontSize: '48px', 
                    color: '#fde047', // Bright Yellow
                    stroke: '#000', 
                    strokeThickness: 6,
                    backgroundColor: '#3b82f6', // Bright Blue
                    padding: { left: 20, right: 20, top: 10, bottom: 10 }
                };
                
                // --- Create UI Groups ---
                // We use groups to easily toggle between GAME_OVER and CREDITS
                this.gameOverGroup = this.add.group();
                this.creditsGroup = this.add.group();

                // --- Game Over Display ---
                const title = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 150, 'GAME OVER', titleStyle).setOrigin(0.5);
                const scoreText = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50, 'FINAL SCORE: ' + this.finalScore, scoreStyle).setOrigin(0.5);

                // --- Buttons ---
                const restartButton = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 80, 'RESTART', buttonStyle)
                    .setOrigin(0.5)
                    .setInteractive({ useHandCursor: true });
                
                this.gameOverGroup.addMultiple([title, scoreText, restartButton]);

                // --- Credits Screen (Section 4.7) ---
                const canShowCredits = this.finalScore >= CREDIT_THRESHOLD;
                
                if (canShowCredits) {
                    const creditsButton = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 180, 'VIEW CREDITS', buttonStyle)
                        .setOrigin(0.5)
                        .setInteractive({ useHandCursor: true });
                    
                    this.gameOverGroup.add(creditsButton);
                    
                    creditsButton.on('pointerdown', () => this.showCredits(true));
                    this.addHoverEffect(creditsButton);
                }

                // --- Credits Display (initially hidden) ---
                const creditsTitle = this.add.text(GAME_WIDTH / 2, 100, 'CREDITS', titleStyle).setOrigin(0.5);
                const creditsBody = this.add.text(GAME_WIDTH / 2, 300, 
                    'A GAME BY:\nSir [Your Name Here]\n\nDESIGN:\nGemini Advanced\n\nTECHNOLOGY:\nPhaser 3', 
                    { ...scoreStyle, fontSize: '40px', align: 'center' }
                ).setOrigin(0.5);
                
                const backButton = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 100, 'BACK', buttonStyle)
                    .setOrigin(0.5)
                    .setInteractive({ useHandCursor: true });
                
                this.creditsGroup.addMultiple([creditsTitle, creditsBody, backButton]);
                this.creditsGroup.setVisible(false); // Hide it

                // --- Button Events ---
                restartButton.on('pointerdown', this.restartGame, this);
                backButton.on('pointerdown', () => this.showCredits(false));
                
                this.addHoverEffect(restartButton);
                this.addHoverEffect(backButton);
            }
            
            addHoverEffect(button) {
                button.on('pointerover', () => button.setStyle({ color: '#FFF' }));
                button.on('pointerout', () => button.setStyle({ color: '#fde047' }));
            }

            showCredits(show) {
                this.gameOverGroup.setVisible(!show);
                this.creditsGroup.setVisible(show);
            }

            restartGame() {
                console.log('Restarting game...');
                // Stop this scene and the UI scene
                this.scene.stop('GameOverScene');
                this.scene.stop('UIScene');
                
                // Restart the main game scene (which triggers UIScene via Boot logic)
                // A full start is cleaner than a restart here
                this.scene.start('BootScene');
            }
        }

        // --- 5. PHASER GAME CONFIGURATION ---

        const config = {
            type: Phaser.AUTO, // Use WebGL if available, otherwise Canvas
            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            parent: 'game-container',
            backgroundColor: '#000000',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: GRAVITY },
                    debug: false // Set to true to see hitboxes
                }
            },
            scene: [BootScene, GameScene, UIScene, GameOverScene]
        };

        // --- 6. START GAME ---
        
        const game = new Phaser.Game(config);

    </script>
</body>
</html>
